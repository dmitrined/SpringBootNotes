# Docker и Spring Boot

Docker позволяет упаковать наше приложение (со всеми настройками, версией Java и библиотеками) в один независимый контейнер, который будет одинаково работать на любом компьютере. Это решает классическую проблему разработчиков: *"А у меня локально всё работало!"*

---

### 1. Зачем нужен Docker?

- **Изоляция:** Приложению не важно, какая ОС или версия Java стоит на сервере. Внутри контейнера есть всё необходимое.
- **Удобство:** Можно одной командой (`docker-compose up`) поднять и само приложение, и базу данных (PostgreSQL), и брокер сообщений (RabbitMQ) без их установки на компьютер.
- **Деплой:** Готовый образ (Image) легко отправить на боевой сервер (Production).

---

### 2. Dockerfile (Упаковка приложения)

`Dockerfile` — это пошаговая инструкция для сборки образа (Image) нашего Spring Boot приложения. Он лежит в корне проекта (рядом с `pom.xml`).

**Пример (Dockerfile):**
```dockerfile
# 1. Берем официальный легкий образ Java (в нашем случае 17-й версии) как основу
FROM eclipse-temurin:17-jdk-alpine

# 2. Указываем рабочую директорию внутри контейнера
WORKDIR /app

# 3. Копируем скомпилированный JAR-файл (он должен быть собран заранее)
# Обычно он ложится в папку target/ после команды Maven
COPY target/my-spring-app-0.0.1-SNAPSHOT.jar app.jar

# 4. Указываем порт, на котором работает приложение (для информации)
EXPOSE 8080

# 5. Команда для запуска приложения при старте контейнера
ENTRYPOINT ["java", "-jar", "app.jar"]
```

> [!TIP]
> **Как собрать JAR-файл перед сборкой образа?**  
> Сначала скомпилируйте проект в терминале: `./mvnw clean package -DskipTests` (для Maven). Это создаст `.jar` файл в папке `target/`.

---

### 3. Docker Compose (Приложение + База Данных)

Обычно Spring Boot работает в связке с базой данных. В нашем примере "Управления пользователями" это **PostgreSQL**. Чтобы не заставлять разработчиков ставить Postgres на компьютер, мы используем `docker-compose.yml`. Он поднимает сразу несколько контейнеров и связывает их в одну локальную сеть.

Файл `docker-compose.yml` также создается в корне проекта:

**Пример (docker-compose.yml):**
```yaml
version: '3.8'

services:
  # 1. Контейнер с базой данных (PostgreSQL)
  postgres-db:
    image: postgres:15-alpine
    container_name: user_db # Имя контейнера
    environment:
      POSTGRES_USER: myuser          # Логин (должен совпадать с настройками Spring)
      POSTGRES_PASSWORD: mypassword  # Пароль
      POSTGRES_DB: user_management     # Название базы данных (создастся автоматически)
    ports:
      - "5432:5432" # Прокидываем порт из контейнера наружу (для подключения через DBeaver / IntelliJ)
    volumes:
      - pgdata:/var/lib/postgresql/data # Сохраняем физические данные на жестком диске (чтобы не удалились после остановки)

  # 2. Наше Spring Boot приложение
  spring-app:
    build: . # Собрать образ по инструкции из Dockerfile в этой же папке
    container_name: user_backend
    ports:
      - "8080:8080" # Прокидываем порт приложения наружу
    environment:
      # ПРИМЕР: Переопределяем настройки из application.properties (для Docker среды)
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres-db:5432/user_management
      SPRING_DATASOURCE_USERNAME: myuser
      SPRING_DATASOURCE_PASSWORD: mypassword
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
    depends_on:
      - postgres-db # Приложение начнёт запускаться только ПОСЛЕ старта базы данных

# Зарегистрированный "том" для хранения байтов базы данных
volumes:
  pgdata: 
```

---

### 4. Подключение к БД: Важный нюанс

Обратите внимание на URL подключения в Compose-файле:  
`SPRING_DATASOURCE_URL: jdbc:postgresql://postgres-db:5432/user_management`

Мы пишем не `localhost`, а **`postgres-db`**! Внутри Docker-сети контейнеры общаются друг с другом по именам своих сервисов.

---

### 5. Полезные команды (Шпаргалка)

Выполняются в терминале в папке с проектом (там, где лежит `docker-compose.yml`):

| Команда | Описание |
| :--- | :--- |
| `docker-compose up -d` | Поднять все контейнеры (БД + Приложение) в фоновом режиме. |
| `docker-compose down` | Остановить и полностью удалить контейнеры. |
| `docker-compose build` | Принудительно пересобрать Spring Boot образ (нужно, если вы изменили Java код и пересобрали `.jar`). |
| `docker-compose logs -f spring-app` | Читать логи только нашего приложения в реальном времени (наблюдать процессы регистрации/ошибок). |
| `docker ps` | Посмотреть список запущенных контейнеров и их статусы. |

---

### 6. Итоговый рабочий процесс (Workflow)

1. Вы написали/исправили код (добавили отправку писем или загрузку файлов).
2. Компилируете обновленный JAR: `./mvnw clean package`
3. Пересобираете и поднимаете контейнеры: `docker-compose up --build -d`
4. Тестируете API через Postman: `POST http://localhost:8080/api/users/register`
5. Данные сохраняются прямо в контейнер PostgreSQL. Всё изолированно и чисто!
