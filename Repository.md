# Слой Репозиторий (Repository)

### Роль
**Репозиторий** — это слой доступа к данным (DAO). Он инкапсулирует в себе всю работу с базой данных (SQL-запросы, поиск, сохранение).

**За что отвечает:**
- Выполнение CRUD операций (Create, Read, Update, Delete).
- Генерация SQL запросов на основе имен методов (Spring Data JPA).
- Выполнение сложных запросов с помощью `@Query`.

**Что делать КАТЕГОРИЧЕСКИ нельзя:**
- Писать бизнес-логику.
- Вызывать другие репозитории (репозиторий должен знать только о своей таблице).

---

### Аннотации

| Аннотация | Описание |
| :--- | :--- |
| `@Repository` | Указывает, что класс работает с БД. (Хотя при использовании JpaRepository её можно не писать, она ставится автоматически). |
| `@Query` | Позволяет написать свой SQL или JPQL запрос вручную, если возможностей стандартных методов не хватает. |
| `@Param` | Связывает переменную в методе с параметром в `@Query`. |

---

### Связи
- Вызывается только из **слоя Service**.
- Работает напрямую с **базой данных** и **Entity (Model)**.

---

### Примеры кода
```java
// Наследуемся от JpaRepository: <Сущность, Тип первичного ключа>
public interface UserRepository extends JpaRepository<User, Long> {

    // Spring сам создаст запрос: SELECT * FROM users WHERE email = ?
    Optional<User> findByEmail(String email);

    // Пример кастомного запроса
    @Query("SELECT u FROM User u WHERE u.role = :role")
    List<User> findAllByRole(@Param("role") Role role);

    boolean existsByEmail(String email);
}
```

---

### Best Practices (Чистый код)
1. **Имена методов**: Используйте возможности Spring Data JPA (findBy..., existsBy..., countBy...). Это избавляет от написания лишнего SQL.
2. **Optional**: Всегда возвращайте `Optional<T>` для методов поиска по ID или уникальному полю, чтобы избежать `NullPointerException`.
3. **Не перегружайте**: Если запрос слишком сложный, возможно, его стоит вынести в отдельный `CustomRepository`.
